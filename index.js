// ÌïÑÏàò Î™®Îìà Î∞è Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨
const fs = require('node:fs');
const path = require('node:path');
const { Client, GatewayIntentBits, Events, Collection } = require('discord.js');
const { 
    DynamoDBClient, 
    GetItemCommand,
    PutItemCommand,
    UpdateItemCommand
} = require('@aws-sdk/client-dynamodb');
const { TranslateClient, TranslateTextCommand } = require('@aws-sdk/client-translate');
const { token } = require('./config.json');

const languageMap = {
    'ko': 'ko',
    'en': 'en',
    'ja': 'ja',
    'zh-TW': 'zh-TW',
    'zh': 'zh'
};   

// config ÌååÏùº Í≤ΩÎ°ú ÏßÄÏ†ï Î∞è Î°úÎî©
const configPath = path.resolve(__dirname, './config.json');
let try_config;
try {
    try_config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
} catch (err) {
    console.error('Config ÌååÏùºÏùÑ ÏùΩÎäî ÎèÑÏ§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ', err);
    process.exit(1); // config ÏùΩÍ∏∞ Ïã§Ìå® Ïãú Ï¢ÖÎ£å
}

// ÎîîÏä§ÏΩîÎìú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± Î∞è Ïù∏ÌÖêÌä∏ ÏÑ§Ï†ï
const client = new Client({ intents: [
    GatewayIntentBits.Guilds, 
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessages, 
    GatewayIntentBits.MessageContent
] });

client.commands = new Collection();

const foldersPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(foldersPath);
for (const folder of commandFolders) {
    const commandsPath = path.join(foldersPath, folder);
    const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

    for (const file of commandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = require(filePath);
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
        } else {
            console.log(`[WARNING] ${filePath}ÏóêÏÑú "data" ÎòêÎäî "execute" ÏÜçÏÑ±Ïù¥ ÎàÑÎùΩÎê®.`);
        }
    }
}

const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));

const dynamodbClient = new DynamoDBClient({
    region: config.region,
    credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
    },
});

const translateClient = new TranslateClient({
    region: config.region,
    credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
    },
});



async function assignRoleIfEligible(member, userData) {

    if (!userData?.Item) {
        console.log('Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        return;
    }

    const chatCount = parseInt(userData.Item.userChat?.N ?? '0');
    const voiceCount = parseInt(userData.Item.joinVoice?.N ?? '0');

    const ROLE_TIERS = config.roleTiers;

    const currentRoleIds = ROLE_TIERS.map(t => t.id);
    const rolesToRemove = member.roles.cache.filter(role => currentRoleIds.includes(role.id));
    for (const [_, role] of rolesToRemove) {
        try {
            await member.roles.remove(role);
        } catch (err) {
            console.error(`‚ùå Ïó≠Ìï† Ï†úÍ±∞ Ïã§Ìå®: ${role.name}`, err);
        }
    }

    for (const tier of ROLE_TIERS) {
        if (chatCount >= tier.chat || voiceCount >= tier.voice) {
            try {
                await member.roles.add(tier.id);
    
                // Î©§Î≤Ñ Ï†ïÎ≥¥ ÏµúÏã†Ìôî
                await member.fetch();
                const alreadyHasTier = member.roles.cache.has(tier.id);
    
                if (!alreadyHasTier) {
                    const targetChannel = member.guild.channels.cache.get(config.welcomeChannelId);
                    if (targetChannel && targetChannel.isTextBased()) {
                        await targetChannel.send(`<@${member.id}> ÎãòÏù¥ <@&${tier.id}> Ïó≠Ìï†Î°ú ÏäπÍ∏âÌñàÏäµÎãàÎã§! üéâ`);
                    }
                }
            } catch (err) {
                console.error(`‚ùå Ïó≠Ìï† Î∂ÄÏó¨ Ïã§Ìå®: ${tier.id}`, err);
            }
            break;
        }
    }
}

client.once(Events.ClientReady, readyClient => {
    console.log(`Ready! Logged in as ${readyClient.user.tag}`);
});

client.on(Events.InteractionCreate, async interaction => {
    if (!interaction.isChatInputCommand()) return;

    const command = interaction.client.commands.get(interaction.commandName);
    if (!command) {
        console.error(`Ìï¥Îãπ Î™ÖÎ†πÏñ¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${interaction.commandName}`);
        return;
    }

    try {
        await command.execute(interaction);
    } catch (error) {
        console.error('Î™ÖÎ†πÏñ¥ Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
        const errorMsg = { content: 'Î™ÖÎ†πÏñ¥ Ïã§Ìñâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', ephemeral: true };
        interaction.replied || interaction.deferred
            ? await interaction.followUp(errorMsg)
            : await interaction.reply(errorMsg);
    }
});

client.on('messageCreate', async message => {
    if (message.author.bot) return;

    const userCountingId = message.author.id;
    const userCountingName = message.author.username;

    const userCountingParams = {
        TableName: config.userStateTable,
        Key: { userId: { S: userCountingId } },
    };

    try {
        const userData = await dynamodbClient.send(new GetItemCommand(userCountingParams));

        if (userData.Item) {
            const updateParams = {
                TableName: config.userStateTable,
                Key: {
                    userId: { S: userCountingId }
                },
                UpdateExpression: config.setUserSatatsTable,
                ExpressionAttributeValues: {
                    ':inc': { N: '1' },
                    ':start': { N: '0' },
                    ':now': { S: new Date().toISOString() }
                }
            };
            await dynamodbClient.send(new UpdateItemCommand(updateParams));
            console.log(`‚úÖ ${userCountingId} userChat +1`);
        } else {
            const putParams = {
                TableName: config.userStateTable,
                Item: {
                    userId: { S: userCountingId },
                    userName: { S: userCountingName },
                    userChat: { N: '1' },
                    joinVoice: { N: '0' },
                    lastUpdated: { S: new Date().toISOString() }
                }
            };
            await dynamodbClient.send(new PutItemCommand(putParams));
            console.log(`Ïã†Í∑ú Ïú†Ï†Ä ${userCountingId} Îì±Î°ù Î∞è userChat = 1`);
        }

        const guildMember = await message.guild.members.fetch(userCountingId);
        await assignRoleIfEligible(guildMember, userData);

    } catch (err) {
        console.error('userChat Ï¶ùÍ∞Ä ÎòêÎäî Ïã†Í∑ú Îì±Î°ù Ïã§Ìå®:', err);
    }

    if (message.content.startsWith('[Translated]')) return;
    if (message.stickers.size > 0) return;

    const onlyEmojis = message.content.trim().match(/^(\p{Emoji_Presentation}|\p{Extended_Pictographic}|\s)+$/u);
    if (onlyEmojis) return;

    if (message.attachments.size > 0) {
        const hasOnlyMedia = [...message.attachments.values()].every(attachment => {
            const mediaTypes = ['image/', 'video/', 'audio/'];
            return mediaTypes.some(type => attachment.contentType?.startsWith(type));
        });
        if (hasOnlyMedia) return;
    }

    const userId = message.author.id;

    // Ïú†Ï†Ä Ï†ïÎ≥¥ Ï°∞Ìöå (DynamoDB)
    const userParams = {
        TableName: config.userTable,
        Key: { userId: { S: userId } },
    };

    try {
        // ÏÑúÎ≤Ñ ÏÑ§Ï†ï Ï°∞Ìöå (Ï±ÑÎÑê Ï†úÌïú ÌôïÏù∏)
        const serverParams = {
            TableName: config.serverTable,
            Key: { serverId: { S: message.guild.id } },
        };
        const serverData = await dynamodbClient.send(new GetItemCommand(serverParams));

        if (serverData.Item) {
            const chattingIDs = serverData.Item.chattingID?.L?.map(item => item.S) ?? [];
            if (!chattingIDs.includes(message.channel.id)) {
                console.log('Î¥áÏù¥ ÏûëÎèôÌïòÏßÄ ÏïäÎèÑÎ°ù ÏÑ§Ï†ïÎêú Ï±ÑÎÑêÏûÖÎãàÎã§.');
                return;
            }
        } else {
            console.error('Server ÌÖåÏù¥Î∏îÏóê ÏÑúÎ≤Ñ Ï†ïÎ≥¥ ÏóÜÏùå');
            return;
        }

        // Ïú†Ï†ÄÏùò Î≤àÏó≠ ÏÑ§Ï†ï Î∞è Ïñ∏Ïñ¥ Ï†ïÎ≥¥ Ï°∞Ìöå
        const userData = await dynamodbClient.send(new GetItemCommand(userParams));

        if (userData.Item) {
            const translateData = userData.Item.transOnOff?.BOOL ?? false;
            let sourceLang = userData.Item.transLang?.M?.source?.S ?? 'ko';
            let targetLang = userData.Item.transLang?.M?.target?.S ?? 'en';

            sourceLang = languageMap[sourceLang] || sourceLang;
            targetLang = languageMap[targetLang] || targetLang;         

            // Î≤àÏó≠Ïù¥ ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞
            if (translateData) {
                const validLangs = ['ko', 'en', 'zh-TW', 'zh', 'ja'];
                const sourceLanguageCode = validLangs.includes(sourceLang) ? sourceLang : 'en';
                const targetLanguageCode = validLangs.includes(targetLang) ? targetLang : 'ko';

                // ‚úÖ Î©òÏÖò ÏπòÌôò Ìï®Ïàò
                function replaceMentionsWithUserTags(message) {
                    let content = message.content;
                    message.mentions.users.forEach(user => {
                        const mentionSyntax = `<@${user.id}>`;
                        const mentionSyntaxWithNick = `<@!${user.id}>`;
                        const userTag = `@${user.username}`;
                        content = content.replaceAll(mentionSyntax, userTag);
                        content = content.replaceAll(mentionSyntaxWithNick, userTag);
                    });
                    return content;
                }

                const originalText = replaceMentionsWithUserTags(message);

                const translateParams = {
                    Text: originalText,
                    SourceLanguageCode: sourceLanguageCode,
                    TargetLanguageCode: targetLanguageCode,
                };

                try {
                    const translateCommand = new TranslateTextCommand(translateParams);
                    const translateResult = await translateClient.send(translateCommand);
                    const translatedText = translateResult.TranslatedText;
                    await message.reply(`${translatedText}`);
                } catch (translateError) {
                    console.error('Î≤àÏó≠ ÏöîÏ≤≠ Ïò§Î•ò:', translateError);
                    await message.reply('Î≤àÏó≠ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.');
                }
            } else {
                console.log(`Î≤àÏó≠ ÎπÑÌôúÏÑ±Ìôî Ïú†Ï†Ä: ${message.author.username}`);
            }
        } else {
            console.error('Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
    } catch (error) {
        console.error('DynamoDB Ï°∞Ìöå Ïò§Î•ò: ', error);
    }
});

client.on('voiceStateUpdate', async (oldState, newState) => {
    const member = newState.member;
    if (!member || member.user.bot) return;

    const userId = member.id;
    const userName = member.user.username;

    const userParams = {
        TableName: config.userStatsTable,
        Key: { userId: { S: userId } },
    };

    // ÏûÖÏû• Ïù¥Î≤§Ìä∏Ïù∏ÏßÄ ÌôïÏù∏ (oldState.channel ÏóÜÏùå && newState.channel ÏûàÏùå)
    if (!oldState.channel && newState.channel) {
        try {
            const userData = await dynamodbClient.send(new GetItemCommand(userParams));

            if (userData.Item) {
                // Ïú†Ï†Ä Ï°¥Ïû¨ ‚Üí joinVoice Ï¶ùÍ∞Ä
                const updateParams = {
                    TableName: config.userStatsTable,
                    Key: {
                        userId: { S: userId }
                    },
                    UpdateExpression: config.setUserStatesTable2,
                    ExpressionAttributeValues: {
                        ':inc': { N: '1' },
                        ':start': { N: '0' },
                        ':now': { S: new Date().toISOString() }
                    }
                };
                await dynamodbClient.send(new UpdateItemCommand(updateParams));
                console.log(`üé§ ${userId} joinVoice +1`);
            } else {
                // Ïú†Ï†Ä ÏóÜÏúºÎ©¥ Ïã†Í∑ú Îì±Î°ù
                const putParams = {
                    TableName: config.userStatsTable,
                    Item: {
                        userId: { S: userId },
                        userName: { S: userName },
                        userChat: { N: '0' },
                        joinVoice: { N: '1' },
                        lastUpdated: { S: new Date().toISOString() }
                    }
                };
                await dynamodbClient.send(new PutItemCommand(putParams));
                console.log(`üÜï ÏùåÏÑ± ÏûÖÏû• Ïã†Í∑ú Ïú†Ï†Ä ${message.author.username} Îì±Î°ù`);
            }
        } catch (err) {
            console.error('joinVoice Ï¶ùÍ∞Ä Ïã§Ìå®:', err);
        }
    }
});


client.login(token);